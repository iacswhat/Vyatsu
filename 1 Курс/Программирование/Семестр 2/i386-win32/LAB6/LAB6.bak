program STACK;
{раздел подключения сторонних модулей}
uses
{подключаем модуль crt - console run time, чтобы можно было
 использовать подпрограммы для работы с консолью}
    crt;
{раздел декларации собственных типов данных}
type
{указательный тип данных на элемент Стека}
    Tptr = ^Telem;
{запись, состоящая из двух полей, описывающая элемент Стека}
    Telem = record
        inf : integer;  {информационное поле - хранит целые числа}
        link : Tptr;    {указательное поле - ссылка на следующий элемент Стека}
    end;
{раздел описания переменных}
var
{глобальная переменная - указатель на вершину Стека}
    top : Tptr;
{---------------------------------------------------------------------------}
{Процедура: добавление элемента в вершину Стека}
{---------------------------------------------------------------------------}
procedure push;
var
{вспомогательный указатель, ссылающийся на добавляемый элемент}
    p : Tptr;
{начало тела процедуры}
begin
{выделение памяти под добавляемый элемент}
    new(p);
{"привязали" линковочное поле к NIL, чтобы не было висячей ссылки}
    p^.link := NIL;
{ввод значения информационного поля элемента с клавиатуры}
    write('Enter the value of the added element: ');
    readln(p^.inf);
{указатель добавляемого элемента поставили на первый элемент Стека}
    p^.link := top;
{указатель на вершину Стека top поставили на только что добавленный элемент.
 В итоге, Стек находится в согласованном состоянии после добавления элемента}
    top := p;
{конец тела процедуры}
end;
{---------------------------------------------------------------------------}
{Процедура: удаление элемента из вершины Стека}
{---------------------------------------------------------------------------}
procedure pop;
var
{вспомогательный указатель, ссылающийся на удаляемый элемент}
    p : Tptr;
{начало тела процедуры}
begin
{позиционируем указатель p на вершину Стека}
    p := top;
{поскольку на первый элемент ссылается уже два указателя p и top,
 следовательно, один из указателей можно "отвязать" от первого элемента.
 Поэтому перемещаем top с верхнего элемента на второй элемент Стека}
    top := p^.link;
{окончательно разрушаем связь между первым и вторым элементом, так как
 первый элемент сейчас будет удаляться}
    p^.link := NIL;
{удаляем первый элемент Стека}
    dispose(p);
{конец тела процедуры}
end;
{---------------------------------------------------------------------------}
{Процедура: печать элементов Стека от вершины в конец}
{---------------------------------------------------------------------------}
procedure printFromTop;
var
{вспомогательный указатель, ссылающийся на текущий элемент Стека}
    p : Tptr;
{начало тела процедуры}
begin
{устанавливаем указатель р на первый элемент Стека}
    p := top;
{выпечатываем на экран диалог}
    write('Stack elements look like: ');
{до тех пор, пока указатель р не выйдет за последний элемент Стека}
    while(p <> NIL) do
    begin
{печатаем на экран пользователя информационное поле текущего элемента Стека,
 причем целые числа печатаются через пробел, чтобы вывод был понятным}
        write(p^.inf, ' ');
{переход на следующий элемент Стека}
        p := p^.link;
    end;
{конец тела процедуры}
end;
{---------------------------------------------------------------------------}
{Рекурсивная (возврат) процедура: печать элементов Стека от конца к вершине}
{---------------------------------------------------------------------------}
{процедура принимает параметр - указатель на вершину Стека}
procedure printRecFromEnd(pp : Tptr);
begin
{любая рекурсия обязана иметь элементарный случай, чтобы завершится. В
 данной процедуре, элементарным случаем является ситуация, когда
 указатель вышел за последний элемент стека, то есть ссылается на NIL}
    if(pp <> NIL) then
    begin
{рекурсивный вызов, в качестве параметра передается указатель на
 следующий элемент Стека}
        printRecFromEnd(pp^.link);
{печать значения информационного поля текущего элемента
 причем целые числа печатаются через пробел, чтобы вывод был понятным}
        write(pp^.inf, ' ');
    end;
{конец тела процедуры}
end;
{---------------------------------------------------------------------------}
{Процедура: удаление всех элементов из Стека}
{---------------------------------------------------------------------------}
procedure delAllStack;
var
{вспомогательный указатель}
    p : Tptr;
begin
{удаление элементов начинается с первого элемента Стека}
    p := top;
{пока не будут удалены все элементы из Стека, то есть пока указатель р
 не станет равным NIL начинаем цикл}
    while(p <> NIL) do
    begin
{чтобы удалить текущий элемент и не потерять связь со следующим, переставляем
 указатель top на следующий элемент Стека}
        top := p^.link;
{окончательно разрушаем связь между удаляемым и следующим элементом, так как
 текущий элемент сейчас будет удаляться}
        p^.link := NIL;
{удаляем верхний элемент из Стека}
        dispose(p);
{установка указателя р снова на вершину Стека}
        p := top;
    end;
{конец тела процедуры}
{*примечание: указатель на вершину Стека top должен ссылаться на NIL}
end;
{---------------------------------------------------------------------------}
{Функция: нахождение количества элементов в Стеке}
{---------------------------------------------------------------------------}
function getCountElem : integer;
var
{вспомогательный указатель}
    p : Tptr;
{хранит количество элементов в Стеке}
    k : integer;
{начало тела функции}
begin
{зануляем количество, так как расчет еще не начался}
    k := 0;
{указатель p стартует с самого верхнего элемента Стека}
    p := top;
{до тех пор пока р не выйдет за последний элемент, то есть в NIL
 будем вести подсчет элементов}
    while(p <> NIL) do
    begin
{счетчик, отвечающий за количество элементов увеличиваем на единицу}
        k := k + 1;
{переходим на следующий элемент Стека}
        p := p^.link;
    end;
{в качестве ответа возвращаем количество элементов в Стеке}
    getCountElem := k;
end;
{---------------------------------------------------------------------------}
{Функция: главное меню программы}
{---------------------------------------------------------------------------}
function menu : integer;
var
{хранит значение пункта меню выбранного пользователем}
    sel : integer;
{начало тела функции}
begin
{запускаем визуализацию пунктов меню в цикле, до тех пор пока, пользователь
 не выберет какой-либо заданный пункт меню}
    repeat
        clrscr;
        writeln('1 - ADD ITEM TO STACK TOP');
        writeln('2 - REMOVE ITEM FROM STACK TOP');
        writeln('3 - PRINTING STACK ELEMENTS ON SCREEN FROM TOP TO DOWN');
        writeln('4 - PRINTING STACK ON SCREEN FROM BOTTOM TO TOP');
        writeln('5 - TOTAL NUMBER OF ELEMENTS IN A STACK');
        writeln('6 - REMOVING ALL ITEMS FROM THE STACK');
        writeln('7 - EXIT');
        writeln;
        write('Choose one of the suggested items: ');
{возможна ошибка ввода, если пользователь введет, например, не число, а
 какой-нибудь символ или даже строковое значение. Обработки ошибок нет!}
{считываем с клавиатуры пункт меню, выбранный пользователем}
        readln(sel);
{стоит небольшая защита на диапазон от 1 до 7}
    until((sel >= 1) and (sel <= 7));
    writeln;
{в качестве ответа возвращается число, указанное пользователем}
    menu := sel;
{конец тела функции}
end;
{---------------------------------------------------------------------------}
{Начало основного блока программы}
{---------------------------------------------------------------------------}
var
{хранит выбор пользователя относительно главного меню}
    sel : integer;
begin
{очистка экрана от прошлых выводов и установка цвета текста белым}
    clrscr;
    textColor(WHITE);
{изначально Стек путь, то есть не содержит элементов}
    top := NIL;
{пока пользователь не выберет пункт меню, отвечающий за выход из программы,
 будет появляться интерактивное меню}
    repeat
{получаем номер операции от пользователя и затем начинаем анализировать
 номер и вызываем соответствующую подпрограмму}
        sel := menu;
        case sel of
            1:
            begin
{вставка элемента в вершину Стека}
                push;
{оповещение пользователя об успешном завершении операции}
                writeln;
                write('New item added successfully!');
                readln;
            end;
            2:
            begin
{если в Стеке нет ни одного элемента, то удаление физически невозможно}
                if(top = NIL) then
                    writeln('There are no items on the stack to remove!')
                else
                begin
{удаление элемента из вершины Стека}
                    pop;
{оповещение пользователя об успешном завершении операции}
                    writeln;
                    write('Removing an element from the top of the Stack has been successfully completed!');
                end;
                readln;
            end;
            3:
            begin
{если в Стеке нет элементов, то вызываем диалог для пользователя}
                if(top = NIL) then
                    write('Items cannot be printed because the Stack is empty!')
                else
{печать элементов Стека от вершины вниз}
                    printFromTop;
                readln;
            end;
            4:
            begin
{если в Стеке нет элементов, то вызываем диалог для пользователя}
                if(top = NIL) then
                    write('Items cannot be printed because the Stack is empty!')
                else
                begin
                    write('Stack elements look like: ');
{рекурсивная печать элементов Стека от конца к вершине}
                    printRecFromEnd(top);
                end;
                readln;
            end;
            5:
            begin
{определяем количество элементов в Стеке}
                write('Number of Stack Elements: ', getCountElem);
                readln;
            end;
            6:
            begin
{удаление всех элементов из Стека}
                delAllStack;
                write('All Stack elements have been successfully removed!');
                readln;
            end;
        end;
    until(sel = 7);
{перед тем, как закрыть программу, обязательно надо вызывать процедуру,
 отвечающую за удаление всех элементов Стека, чтобы не было утечки памяти}
    delAllStack;
{конец главного блока программы}
end.
